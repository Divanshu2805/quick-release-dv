"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-schema-list";
exports.ids = ["vendor-chunks/prosemirror-schema-list"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-schema-list/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* binding */ addListNodes),\n/* harmony export */   bulletList: () => (/* binding */ bulletList),\n/* harmony export */   liftListItem: () => (/* binding */ liftListItem),\n/* harmony export */   listItem: () => (/* binding */ listItem),\n/* harmony export */   orderedList: () => (/* binding */ orderedList),\n/* harmony export */   sinkListItem: () => (/* binding */ sinkListItem),\n/* harmony export */   splitListItem: () => (/* binding */ splitListItem),\n/* harmony export */   wrapInList: () => (/* binding */ wrapInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\nconst olDOM = [\n    \"ol\",\n    0\n], ulDOM = [\n    \"ul\",\n    0\n], liDOM = [\n    \"li\",\n    0\n];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/ const orderedList = {\n    attrs: {\n        order: {\n            default: 1\n        }\n    },\n    parseDOM: [\n        {\n            tag: \"ol\",\n            getAttrs (dom) {\n                return {\n                    order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1\n                };\n            }\n        }\n    ],\n    toDOM (node) {\n        return node.attrs.order == 1 ? olDOM : [\n            \"ol\",\n            {\n                start: node.attrs.order\n            },\n            0\n        ];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/ const bulletList = {\n    parseDOM: [\n        {\n            tag: \"ul\"\n        }\n    ],\n    toDOM () {\n        return ulDOM;\n    }\n};\n/**\nA list item (`<li>`) spec.\n*/ const listItem = {\n    parseDOM: [\n        {\n            tag: \"li\"\n        }\n    ],\n    toDOM () {\n        return liDOM;\n    },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for(let prop in obj)copy[prop] = obj[prop];\n    for(let prop in props)copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/ function addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, {\n            content: \"list_item+\",\n            group: listGroup\n        }),\n        bullet_list: add(bulletList, {\n            content: \"list_item+\",\n            group: listGroup\n        }),\n        list_item: add(listItem, {\n            content: itemContent\n        })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/ function wrapInList(listType, attrs = null) {\n    return function(state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), doJoin = false, outerRange = range;\n        if (!range) return false;\n        // This is at the top of an existing list item\n        if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n            // Don't do anything if this is the top of the list\n            if ($from.index(range.depth - 1) == 0) return false;\n            let $insert = state.doc.resolve(range.start - 2);\n            outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($insert, $insert, range.depth);\n            if (range.endIndex < range.parent.childCount) range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\n            doJoin = true;\n        }\n        let wrap = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(outerRange, listType, attrs, range);\n        if (!wrap) return false;\n        if (dispatch) dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\n        return true;\n    };\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for(let i = wrappers.length - 1; i >= 0; i--)content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for(let i = 0; i < wrappers.length; i++)if (wrappers[i].type == listType) found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for(let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false){\n        if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/ function splitListItem(itemType, itemAttrs) {\n    return function(state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType) return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;\n            if (dispatch) {\n                let wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for(let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos)=>{\n                    if (sel > -1) return false;\n                    if (node.isTextblock && node.content.size == 0) sel = pos + 1;\n                });\n                if (sel > -1) tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [\n            itemAttrs ? {\n                type: itemType,\n                attrs: itemAttrs\n            } : null,\n            {\n                type: nextType\n            }\n        ] : undefined;\n        if (!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, $from.pos, 2, types)) return false;\n        if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/ function liftListItem(itemType) {\n    return function(state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, (node)=>node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range) return false;\n        if (!dispatch) return true;\n        if ($from.node(range.depth - 1).type == itemType) return liftToOuterList(state, dispatch, itemType, range);\n        else return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    const target = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.liftTarget)(range);\n    if (target == null) return false;\n    tr.lift(range, target);\n    let after = tr.mapping.map(end, -1) - 1;\n    if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, after)) tr.join(after);\n    dispatch(tr.scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for(let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--){\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list)))) return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))).append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/ function sinkListItem(itemType) {\n    return function(state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, (node)=>node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range) return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0) return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType) return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());\n        }\n        return true;\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc2NoZW1hLWxpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF1RztBQUN4QztBQUNqQjtBQUU5QyxNQUFNUyxRQUFRO0lBQUM7SUFBTTtDQUFFLEVBQUVDLFFBQVE7SUFBQztJQUFNO0NBQUUsRUFBRUMsUUFBUTtJQUFDO0lBQU07Q0FBRTtBQUM3RDs7Ozs7QUFLQSxHQUNBLE1BQU1DLGNBQWM7SUFDaEJDLE9BQU87UUFBRUMsT0FBTztZQUFFQyxTQUFTO1FBQUU7SUFBRTtJQUMvQkMsVUFBVTtRQUFDO1lBQUVDLEtBQUs7WUFBTUMsVUFBU0MsR0FBRztnQkFDeEIsT0FBTztvQkFBRUwsT0FBT0ssSUFBSUMsWUFBWSxDQUFDLFdBQVcsQ0FBQ0QsSUFBSUUsWUFBWSxDQUFDLFdBQVc7Z0JBQUU7WUFDL0U7UUFBRTtLQUFFO0lBQ1pDLE9BQU1DLElBQUk7UUFDTixPQUFPQSxLQUFLVixLQUFLLENBQUNDLEtBQUssSUFBSSxJQUFJTCxRQUFRO1lBQUM7WUFBTTtnQkFBRWUsT0FBT0QsS0FBS1YsS0FBSyxDQUFDQyxLQUFLO1lBQUM7WUFBRztTQUFFO0lBQ2pGO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLE1BQU1XLGFBQWE7SUFDZlQsVUFBVTtRQUFDO1lBQUVDLEtBQUs7UUFBSztLQUFFO0lBQ3pCSztRQUFVLE9BQU9aO0lBQU87QUFDNUI7QUFDQTs7QUFFQSxHQUNBLE1BQU1nQixXQUFXO0lBQ2JWLFVBQVU7UUFBQztZQUFFQyxLQUFLO1FBQUs7S0FBRTtJQUN6Qks7UUFBVSxPQUFPWDtJQUFPO0lBQ3hCZ0IsVUFBVTtBQUNkO0FBQ0EsU0FBU0MsSUFBSUMsR0FBRyxFQUFFQyxLQUFLO0lBQ25CLElBQUlDLE9BQU8sQ0FBQztJQUNaLElBQUssSUFBSUMsUUFBUUgsSUFDYkUsSUFBSSxDQUFDQyxLQUFLLEdBQUdILEdBQUcsQ0FBQ0csS0FBSztJQUMxQixJQUFLLElBQUlBLFFB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QUNpRyxTQUFVbUMsQ0FBQUEsZUFBZSxJQUFJLElBQUlqQyxPQUFPRixRQUFRRSxPQUFPb0MsT0FBTyxHQUFHLE9BQ3pHbkUsY0FBYztRQUN2QjtRQUNBLE9BQU87SUFDWDtBQUNKO0FBRWtIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1ibG9nLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0L2Rpc3QvaW5kZXguanM/NWU2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaW5kV3JhcHBpbmcsIFJlcGxhY2VBcm91bmRTdGVwLCBjYW5TcGxpdCwgbGlmdFRhcmdldCwgY2FuSm9pbiB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBOb2RlUmFuZ2UsIEZyYWdtZW50LCBTbGljZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuY29uc3Qgb2xET00gPSBbXCJvbFwiLCAwXSwgdWxET00gPSBbXCJ1bFwiLCAwXSwgbGlET00gPSBbXCJsaVwiLCAwXTtcbi8qKlxuQW4gb3JkZXJlZCBsaXN0IFtub2RlIHNwZWNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYykuIEhhcyBhIHNpbmdsZVxuYXR0cmlidXRlLCBgb3JkZXJgLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBudW1iZXIgYXQgd2hpY2ggdGhlIGxpc3RcbnN0YXJ0cyBjb3VudGluZywgYW5kIGRlZmF1bHRzIHRvIDEuIFJlcHJlc2VudGVkIGFzIGFuIGA8b2w+YFxuZWxlbWVudC5cbiovXG5jb25zdCBvcmRlcmVkTGlzdCA9IHtcbiAgICBhdHRyczogeyBvcmRlcjogeyBkZWZhdWx0OiAxIH0gfSxcbiAgICBwYXJzZURPTTogW3sgdGFnOiBcIm9sXCIsIGdldEF0dHJzKGRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG9yZGVyOiBkb20uaGFzQXR0cmlidXRlKFwic3RhcnRcIikgPyArZG9tLmdldEF0dHJpYnV0ZShcInN0YXJ0XCIpIDogMSB9O1xuICAgICAgICAgICAgfSB9XSxcbiAgICB0b0RPTShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmF0dHJzLm9yZGVyID09IDEgPyBvbERPTSA6IFtcIm9sXCIsIHsgc3RhcnQ6IG5vZGUuYXR0cnMub3JkZXIgfSwgMF07XG4gICAgfVxufTtcbi8qKlxuQSBidWxsZXQgbGlzdCBub2RlIHNwZWMsIHJlcHJlc2VudGVkIGluIHRoZSBET00gYXMgYDx1bD5gLlxuKi9cbmNvbnN0IGJ1bGxldExpc3QgPSB7XG4gICAgcGFyc2VET006IFt7IHRhZzogXCJ1bFwiIH1dLFxuICAgIHRvRE9NKCkgeyByZXR1cm4gdWxET007IH1cbn07XG4vKipcbkEgbGlzdCBpdGVtIChgPGxpPmApIHNwZWMuXG4qL1xuY29uc3QgbGlzdEl0ZW0gPSB7XG4gICAgcGFyc2VET006IFt7IHRhZzogXCJsaVwiIH1dLFxuICAgIHRvRE9NKCkgeyByZXR1cm4gbGlET007IH0sXG4gICAgZGVmaW5pbmc6IHRydWVcbn07XG5mdW5jdGlvbiBhZGQob2JqLCBwcm9wcykge1xuICAgIGxldCBjb3B5ID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcylcbiAgICAgICAgY29weVtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuLyoqXG5Db252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgYWRkaW5nIGxpc3QtcmVsYXRlZCBub2RlIHR5cGVzIHRvIGEgbWFwXG5zcGVjaWZ5aW5nIHRoZSBub2RlcyBmb3IgYSBzY2hlbWEuIEFkZHNcbltgb3JkZXJlZExpc3RgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3Qub3JkZXJlZExpc3QpIGFzIGBcIm9yZGVyZWRfbGlzdFwiYCxcbltgYnVsbGV0TGlzdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5idWxsZXRMaXN0KSBhcyBgXCJidWxsZXRfbGlzdFwiYCwgYW5kXG5bYGxpc3RJdGVtYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0Lmxpc3RJdGVtKSBhcyBgXCJsaXN0X2l0ZW1cImAuXG5cbmBpdGVtQ29udGVudGAgZGV0ZXJtaW5lcyB0aGUgY29udGVudCBleHByZXNzaW9uIGZvciB0aGUgbGlzdCBpdGVtcy5cbklmIHlvdSB3YW50IHRoZSBjb21tYW5kcyBkZWZpbmVkIGluIHRoaXMgbW9kdWxlIHRvIGFwcGx5IHRvIHlvdXJcbmxpc3Qgc3RydWN0dXJlLCBpdCBzaG91bGQgaGF2ZSBhIHNoYXBlIGxpa2UgYFwicGFyYWdyYXBoIGJsb2NrKlwiYCBvclxuYFwicGFyYWdyYXBoIChvcmRlcmVkX2xpc3QgfCBidWxsZXRfbGlzdCkqXCJgLiBgbGlzdEdyb3VwYCBjYW4gYmVcbmdpdmVuIHRvIGFzc2lnbiBhIGdyb3VwIG5hbWUgdG8gdGhlIGxpc3Qgbm9kZSB0eXBlcywgZm9yIGV4YW1wbGVcbmBcImJsb2NrXCJgLlxuKi9cbmZ1bmN0aW9uIGFkZExpc3ROb2Rlcyhub2RlcywgaXRlbUNvbnRlbnQsIGxpc3RHcm91cCkge1xuICAgIHJldHVybiBub2Rlcy5hcHBlbmQoe1xuICAgICAgICBvcmRlcmVkX2xpc3Q6IGFkZChvcmRlcmVkTGlzdCwgeyBjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cCB9KSxcbiAgICAgICAgYnVsbGV0X2xpc3Q6IGFkZChidWxsZXRMaXN0LCB7IGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLCBncm91cDogbGlzdEdyb3VwIH0pLFxuICAgICAgICBsaXN0X2l0ZW06IGFkZChsaXN0SXRlbSwgeyBjb250ZW50OiBpdGVtQ29udGVudCB9KVxuICAgIH0pO1xufVxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZSBzZWxlY3Rpb24gaW4gYSBsaXN0IHdpdGhcbnRoZSBnaXZlbiB0eXBlIGFuIGF0dHJpYnV0ZXMuIElmIGBkaXNwYXRjaGAgaXMgbnVsbCwgb25seSByZXR1cm4gYVxudmFsdWUgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIGlzIHBvc3NpYmxlLCBidXQgZG9uJ3QgYWN0dWFsbHlcbnBlcmZvcm0gdGhlIGNoYW5nZS5cbiovXG5mdW5jdGlvbiB3cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgZG9Kb2luID0gZmFsc2UsIG91dGVyUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVGhpcyBpcyBhdCB0aGUgdG9wIG9mIGFuIGV4aXN0aW5nIGxpc3QgaXRlbVxuICAgICAgICBpZiAocmFuZ2UuZGVwdGggPj0gMiAmJiAkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZS5jb21wYXRpYmxlQ29udGVudChsaXN0VHlwZSkgJiYgcmFuZ2Uuc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGlzIGlzIHRoZSB0b3Agb2YgdGhlIGxpc3RcbiAgICAgICAgICAgIGlmICgkZnJvbS5pbmRleChyYW5nZS5kZXB0aCAtIDEpID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0ICRpbnNlcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCAtIDIpO1xuICAgICAgICAgICAgb3V0ZXJSYW5nZSA9IG5ldyBOb2RlUmFuZ2UoJGluc2VydCwgJGluc2VydCwgcmFuZ2UuZGVwdGgpO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVuZEluZGV4IDwgcmFuZ2UucGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRmcm9tLCBzdGF0ZS5kb2MucmVzb2x2ZSgkdG8uZW5kKHJhbmdlLmRlcHRoKSksIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgICAgIGRvSm9pbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdyYXAgPSBmaW5kV3JhcHBpbmcob3V0ZXJSYW5nZSwgbGlzdFR5cGUsIGF0dHJzLCByYW5nZSk7XG4gICAgICAgIGlmICghd3JhcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goZG9XcmFwSW5MaXN0KHN0YXRlLnRyLCByYW5nZSwgd3JhcCwgZG9Kb2luLCBsaXN0VHlwZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBkb1dyYXBJbkxpc3QodHIsIHJhbmdlLCB3cmFwcGVycywgam9pbkJlZm9yZSwgbGlzdFR5cGUpIHtcbiAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChyYW5nZS5zdGFydCAtIChqb2luQmVmb3JlID8gMiA6IDApLCByYW5nZS5lbmQsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG4gICAgbGV0IGZvdW5kID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXBwZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAod3JhcHBlcnNbaV0udHlwZSA9PSBsaXN0VHlwZSlcbiAgICAgICAgICAgIGZvdW5kID0gaSArIDE7XG4gICAgbGV0IHNwbGl0RGVwdGggPSB3cmFwcGVycy5sZW5ndGggLSBmb3VuZDtcbiAgICBsZXQgc3BsaXRQb3MgPSByYW5nZS5zdGFydCArIHdyYXBwZXJzLmxlbmd0aCAtIChqb2luQmVmb3JlID8gMiA6IDApLCBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gICAgZm9yIChsZXQgaSA9IHJhbmdlLnN0YXJ0SW5kZXgsIGUgPSByYW5nZS5lbmRJbmRleCwgZmlyc3QgPSB0cnVlOyBpIDwgZTsgaSsrLCBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghZmlyc3QgJiYgY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgc3BsaXREZXB0aCkpIHtcbiAgICAgICAgICAgIHRyLnNwbGl0KHNwbGl0UG9zLCBzcGxpdERlcHRoKTtcbiAgICAgICAgICAgIHNwbGl0UG9zICs9IDIgKiBzcGxpdERlcHRoO1xuICAgICAgICB9XG4gICAgICAgIHNwbGl0UG9zICs9IHBhcmVudC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuLyoqXG5CdWlsZCBhIGNvbW1hbmQgdGhhdCBzcGxpdHMgYSBub24tZW1wdHkgdGV4dGJsb2NrIGF0IHRoZSB0b3AgbGV2ZWxcbm9mIGEgbGlzdCBpdGVtIGJ5IGFsc28gc3BsaXR0aW5nIHRoYXQgbGlzdCBpdGVtLlxuKi9cbmZ1bmN0aW9uIHNwbGl0TGlzdEl0ZW0oaXRlbVR5cGUsIGl0ZW1BdHRycykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8sIG5vZGUgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChub2RlICYmIG5vZGUuaXNCbG9jaykgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpO1xuICAgICAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPSBpdGVtVHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgICAgICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAgICAgICAgIC8vIGxpc3QgaXRlbSBzaG91bGQgYmUgc3BsaXQuIE90aGVyd2lzZSwgYmFpbCBvdXQgYW5kIGxldCBuZXh0XG4gICAgICAgICAgICAvLyBjb21tYW5kIGhhbmRsZSBsaWZ0aW5nLlxuICAgICAgICAgICAgaWYgKCRmcm9tLmRlcHRoID09IDMgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPSBpdGVtVHlwZSB8fFxuICAgICAgICAgICAgICAgICRmcm9tLmluZGV4KC0yKSAhPSAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50IC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBhIGZyYWdtZW50IGNvbnRhaW5pbmcgZW1wdHkgdmVyc2lvbnMgb2YgdGhlIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIG91dGVyIGxpc3QgaXRlbSB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIGN1cnNvclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZC0tKVxuICAgICAgICAgICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMVxuICAgICAgICAgICAgICAgICAgICA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgICAgICAgICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGVBbmRGaWxsKCkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIucmVwbGFjZShzdGFydCwgJGZyb20uYWZ0ZXIoLWRlcHRoQWZ0ZXIpLCBuZXcgU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IC0xO1xuICAgICAgICAgICAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiBub2RlLmNvbnRlbnQuc2l6ZSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFR5cGUgPSAkdG8ucG9zID09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5kZWxldGUoJGZyb20ucG9zLCAkdG8ucG9zKTtcbiAgICAgICAgbGV0IHR5cGVzID0gbmV4dFR5cGUgPyBbaXRlbUF0dHJzID8geyB0eXBlOiBpdGVtVHlwZSwgYXR0cnM6IGl0ZW1BdHRycyB9IDogbnVsbCwgeyB0eXBlOiBuZXh0VHlwZSB9XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMiwgdHlwZXMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCB0byBsaWZ0IHRoZSBsaXN0IGl0ZW0gYXJvdW5kIHRoZSBzZWxlY3Rpb24gdXAgaW50b1xuYSB3cmFwcGluZyBsaXN0LlxuKi9cbmZ1bmN0aW9uIGxpZnRMaXN0SXRlbShpdGVtVHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8sIG5vZGUgPT4gbm9kZS5jaGlsZENvdW50ID4gMCAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PSBpdGVtVHlwZSk7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGlzcGF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlID09IGl0ZW1UeXBlKSAvLyBJbnNpZGUgYSBwYXJlbnQgbGlzdFxuICAgICAgICAgICAgcmV0dXJuIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSk7XG4gICAgICAgIGVsc2UgLy8gT3V0ZXIgbGlzdCBub2RlXG4gICAgICAgICAgICByZXR1cm4gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlmdFRvT3V0ZXJMaXN0KHN0YXRlLCBkaXNwYXRjaCwgaXRlbVR5cGUsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGVuZCA9IHJhbmdlLmVuZCwgZW5kT2ZMaXN0ID0gcmFuZ2UuJHRvLmVuZChyYW5nZS5kZXB0aCk7XG4gICAgaWYgKGVuZCA8IGVuZE9mTGlzdCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc2libGluZ3MgYWZ0ZXIgdGhlIGxpZnRlZCBpdGVtcywgd2hpY2ggbXVzdCBiZWNvbWVcbiAgICAgICAgLy8gY2hpbGRyZW4gb2YgdGhlIGxhc3QgaXRlbVxuICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChlbmQgLSAxLCBlbmRPZkxpc3QsIGVuZCwgZW5kT2ZMaXN0LCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGUobnVsbCwgcmFuZ2UucGFyZW50LmNvcHkoKSkpLCAxLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UodHIuZG9jLnJlc29sdmUocmFuZ2UuJGZyb20ucG9zKSwgdHIuZG9jLnJlc29sdmUoZW5kT2ZMaXN0KSwgcmFuZ2UuZGVwdGgpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0ci5saWZ0KHJhbmdlLCB0YXJnZXQpO1xuICAgIGxldCBhZnRlciA9IHRyLm1hcHBpbmcubWFwKGVuZCwgLTEpIC0gMTtcbiAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGFmdGVyKSlcbiAgICAgICAgdHIuam9pbihhZnRlcik7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpIHtcbiAgICBsZXQgdHIgPSBzdGF0ZS50ciwgbGlzdCA9IHJhbmdlLnBhcmVudDtcbiAgICAvLyBNZXJnZSB0aGUgbGlzdCBpdGVtcyBpbnRvIGEgc2luZ2xlIGJpZyBpdGVtXG4gICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZW5kLCBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBlID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGU7IGktLSkge1xuICAgICAgICBwb3MgLT0gbGlzdC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgdHIuZGVsZXRlKHBvcyAtIDEsIHBvcyArIDEpO1xuICAgIH1cbiAgICBsZXQgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQpLCBpdGVtID0gJHN0YXJ0Lm5vZGVBZnRlcjtcbiAgICBpZiAodHIubWFwcGluZy5tYXAocmFuZ2UuZW5kKSAhPSByYW5nZS5zdGFydCArICRzdGFydC5ub2RlQWZ0ZXIubm9kZVNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYXRTdGFydCA9IHJhbmdlLnN0YXJ0SW5kZXggPT0gMCwgYXRFbmQgPSByYW5nZS5lbmRJbmRleCA9PSBsaXN0LmNoaWxkQ291bnQ7XG4gICAgbGV0IHBhcmVudCA9ICRzdGFydC5ub2RlKC0xKSwgaW5kZXhCZWZvcmUgPSAkc3RhcnQuaW5kZXgoLTEpO1xuICAgIGlmICghcGFyZW50LmNhblJlcGxhY2UoaW5kZXhCZWZvcmUgKyAoYXRTdGFydCA/IDAgOiAxKSwgaW5kZXhCZWZvcmUgKyAxLCBpdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QpKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc3RhcnQgPSAkc3RhcnQucG9zLCBlbmQgPSBzdGFydCArIGl0ZW0ubm9kZVNpemU7XG4gICAgLy8gU3RyaXAgb2ZmIHRoZSBzdXJyb3VuZGluZyBsaXN0LiBBdCB0aGUgc2lkZXMgd2hlcmUgd2UncmUgbm90IGF0XG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgbGlzdCwgdGhlIGV4aXN0aW5nIGxpc3QgaXMgY2xvc2VkLiBBdCBzaWRlcyB3aGVyZVxuICAgIC8vIHRoaXMgaXMgdGhlIGVuZCwgaXQgaXMgb3ZlcndyaXR0ZW4gdG8gaXRzIGVuZC5cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IFNsaWNlKChhdFN0YXJ0ID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKVxuICAgICAgICAuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKSwgYXRTdGFydCA/IDAgOiAxLCBhdEVuZCA/IDAgOiAxKSwgYXRTdGFydCA/IDAgOiAxKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gc2luayB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGRvd25cbmludG8gYW4gaW5uZXIgbGlzdC5cbiovXG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBwYXJlbnQgPSByYW5nZS5wYXJlbnQsIG5vZGVCZWZvcmUgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpO1xuICAgICAgICBpZiAobm9kZUJlZm9yZS50eXBlICE9IGl0ZW1UeXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBuZXN0ZWRCZWZvcmUgPSBub2RlQmVmb3JlLmxhc3RDaGlsZCAmJiBub2RlQmVmb3JlLmxhc3RDaGlsZC50eXBlID09IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgbGV0IGlubmVyID0gRnJhZ21lbnQuZnJvbShuZXN0ZWRCZWZvcmUgPyBpdGVtVHlwZS5jcmVhdGUoKSA6IG51bGwpO1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20ocGFyZW50LnR5cGUuY3JlYXRlKG51bGwsIGlubmVyKSkpKSwgbmVzdGVkQmVmb3JlID8gMyA6IDEsIDApO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHJhbmdlLnN0YXJ0LCBhZnRlciA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKGJlZm9yZSAtIChuZXN0ZWRCZWZvcmUgPyAzIDogMSksIGFmdGVyLCBiZWZvcmUsIGFmdGVyLCBzbGljZSwgMSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGFkZExpc3ROb2RlcywgYnVsbGV0TGlzdCwgbGlmdExpc3RJdGVtLCBsaXN0SXRlbSwgb3JkZXJlZExpc3QsIHNpbmtMaXN0SXRlbSwgc3BsaXRMaXN0SXRlbSwgd3JhcEluTGlzdCB9O1xuIl0sIm5hbWVzIjpbImZpbmRXcmFwcGluZyIsIlJlcGxhY2VBcm91bmRTdGVwIiwiY2FuU3BsaXQiLCJsaWZ0VGFyZ2V0IiwiY2FuSm9pbiIsIk5vZGVSYW5nZSIsIkZyYWdtZW50IiwiU2xpY2UiLCJTZWxlY3Rpb24iLCJvbERPTSIsInVsRE9NIiwibGlET00iLCJvcmRlcmVkTGlzdCIsImF0dHJzIiwib3JkZXIiLCJkZWZhdWx0IiwicGFyc2VET00iLCJ0YWciLCJnZXRBdHRycyIsImRvbSIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsInRvRE9NIiwibm9kZSIsInN0YXJ0IiwiYnVsbGV0TGlzdCIsImxpc3RJdGVtIiwiZGVmaW5pbmciLCJhZGQiLCJvYmoiLCJwcm9wcyIsImNvcHkiLCJwcm9wIiwiYWRkTGlzdE5vZGVzIiwibm9kZXMiLCJpdGVtQ29udGVudCIsImxpc3RHcm91cCIsImFwcGVuZCIsIm9yZGVyZWRfbGlzdCIsImNvbnRlbnQiLCJncm91cCIsImJ1bGxldF9saXN0IiwibGlzdF9pdGVtIiwid3JhcEluTGlzdCIsImxpc3RUeXBlIiwic3RhdGUiLCJkaXNwYXRjaCIsIiRmcm9tIiwiJHRvIiwic2VsZWN0aW9uIiwicmFuZ2UiLCJibG9ja1JhbmdlIiwiZG9Kb2luIiwib3V0ZXJSYW5nZSIsImRlcHRoIiwidHlwZSIsImNvbXBhdGlibGVDb250ZW50Iiwic3RhcnRJbmRleCIsImluZGV4IiwiJGluc2VydCIsImRvYyIsInJlc29sdmUiLCJlbmRJbmRleCIsInBhcmVudCIsImNoaWxkQ291bnQiLCJlbmQiLCJ3cmFwIiwiZG9XcmFwSW5MaXN0IiwidHIiLCJzY3JvbGxJbnRvVmlldyIsIndyYXBwZXJzIiwiam9pbkJlZm9yZSIsImVtcHR5IiwiaSIsImxlbmd0aCIsImZyb20iLCJjcmVhdGUiLCJzdGVwIiwiZm91bmQiLCJzcGxpdERlcHRoIiwic3BsaXRQb3MiLCJlIiwiZmlyc3QiLCJzcGxpdCIsImNoaWxkIiwibm9kZVNpemUiLCJzcGxpdExpc3RJdGVtIiwiaXRlbVR5cGUiLCJpdGVtQXR0cnMiLCJpc0Jsb2NrIiwic2FtZVBhcmVudCIsImdyYW5kUGFyZW50Iiwic2l6ZSIsImluZGV4QWZ0ZXIiLCJkZXB0aEJlZm9yZSIsImQiLCJkZXB0aEFmdGVyIiwiY3JlYXRlQW5kRmlsbCIsImJlZm9yZSIsInJlcGxhY2UiLCJhZnRlciIsInNlbCIsIm5vZGVzQmV0d2VlbiIsInBvcyIsImlzVGV4dGJsb2NrIiwic2V0U2VsZWN0aW9uIiwibmVhciIsIm5leHRUeXBlIiwiY29udGVudE1hdGNoQXQiLCJkZWZhdWx0VHlwZSIsImRlbGV0ZSIsInR5cGVzIiwidW5kZWZpbmVkIiwibGlmdExpc3RJdGVtIiwiZmlyc3RDaGlsZCIsImxpZnRUb091dGVyTGlzdCIsImxpZnRPdXRPZkxpc3QiLCJlbmRPZkxpc3QiLCJ0YXJnZXQiLCJsaWZ0IiwibWFwcGluZyIsIm1hcCIsImpvaW4iLCJsaXN0IiwiJHN0YXJ0IiwiaXRlbSIsIm5vZGVBZnRlciIsImF0U3RhcnQiLCJhdEVuZCIsImluZGV4QmVmb3JlIiwiY2FuUmVwbGFjZSIsInNpbmtMaXN0SXRlbSIsIm5vZGVCZWZvcmUiLCJuZXN0ZWRCZWZvcmUiLCJsYXN0Q2hpbGQiLCJpbm5lciIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-schema-list/dist/index.js\n");

/***/ })

};
;